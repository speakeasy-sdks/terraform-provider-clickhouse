// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package provider

import (
	"clickhouse/internal/sdk"
	"clickhouse/internal/sdk/pkg/models/operations"
	"context"
	"fmt"

	"clickhouse/internal/validators"
	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/boolplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/numberplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
) // Ensure provider defined types fully satisfy framework interfaces.
var _ resource.Resource = &ServiceResource{}
var _ resource.ResourceWithImportState = &ServiceResource{}

func NewServiceResource() resource.Resource {
	return &ServiceResource{}
}

// ServiceResource defines the resource implementation.
type ServiceResource struct {
	client *sdk.SDK
}

// ServiceResourceModel describes the resource data model.
type ServiceResourceModel struct {
	BackupID           types.String        `tfsdk:"backup_id"`
	CloudProvider      types.String        `tfsdk:"cloud_provider"`
	CreatedAt          types.String        `tfsdk:"created_at"`
	Endpoints          []ServiceEndpoint   `tfsdk:"endpoints"`
	ID                 types.String        `tfsdk:"id"`
	IdleScaling        types.Bool          `tfsdk:"idle_scaling"`
	IdleTimeoutMinutes types.Number        `tfsdk:"idle_timeout_minutes"`
	IPAccessList       []IPAccessListEntry `tfsdk:"ip_access_list"`
	MaxTotalMemoryGb   types.Number        `tfsdk:"max_total_memory_gb"`
	MinTotalMemoryGb   types.Number        `tfsdk:"min_total_memory_gb"`
	Name               types.String        `tfsdk:"name"`
	OrganizationID     types.String        `tfsdk:"organization_id"`
	Password           types.String        `tfsdk:"password"`
	Region             types.String        `tfsdk:"region"`
	State              types.String        `tfsdk:"state"`
	Tier               types.String        `tfsdk:"tier"`
}

func (r *ServiceResource) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_service"
}

func (r *ServiceResource) Schema(ctx context.Context, req resource.SchemaRequest, resp *resource.SchemaResponse) {
	resp.Schema = schema.Schema{
		MarkdownDescription: "Service Resource",

		Attributes: map[string]schema.Attribute{
			"backup_id": schema.StringAttribute{
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
				Optional:    true,
				Description: `Optional backup ID used as an initial state for the new service. When used the region and the tier of the new instance must be the same as the values of the original instance.`,
			},
			"cloud_provider": schema.StringAttribute{
				Computed: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
				Optional: true,
				Validators: []validator.String{
					stringvalidator.OneOf(
						"aws",
						"gcp",
					),
				},
				MarkdownDescription: `must be one of [aws, gcp]` + "\n" +
					`Cloud provider`,
			},
			"created_at": schema.StringAttribute{
				Computed: true,
				Validators: []validator.String{
					validators.IsRFC3339(),
				},
				Description: `Service creation timestamp. ISO-8601.`,
			},
			"endpoints": schema.ListNestedAttribute{
				Computed: true,
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"host": schema.StringAttribute{
							Computed:    true,
							Description: `Service host name`,
						},
						"port": schema.NumberAttribute{
							Computed:    true,
							Description: `Numeric port`,
						},
						"protocol": schema.StringAttribute{
							Computed: true,
							Validators: []validator.String{
								stringvalidator.OneOf(
									"https",
									"nativesecure",
								),
							},
							MarkdownDescription: `must be one of [https, nativesecure]` + "\n" +
								`Endpoint protocol: 'https', 'nativesecure'.`,
						},
					},
				},
				Description: `List of all service endpoints.`,
			},
			"id": schema.StringAttribute{
				Computed:    true,
				Description: `Unique service ID.`,
			},
			"idle_scaling": schema.BoolAttribute{
				Computed: true,
				PlanModifiers: []planmodifier.Bool{
					boolplanmodifier.RequiresReplace(),
				},
				Optional:    true,
				Description: `When set to true the service is allowed to scale down to zero when idle. Always true for development services.`,
			},
			"idle_timeout_minutes": schema.NumberAttribute{
				Computed: true,
				PlanModifiers: []planmodifier.Number{
					numberplanmodifier.RequiresReplace(),
				},
				Optional:    true,
				Description: `Set minimum idling timeout (in minutes). Must be &gt;= 5 minutes.`,
			},
			"ip_access_list": schema.ListNestedAttribute{
				Computed: true,
				Optional: true,
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"description": schema.StringAttribute{
							Required:    true,
							Description: `IPv4 address or IPv4 CIDR to allow access from`,
						},
						"source": schema.StringAttribute{
							Required:    true,
							Description: `IP or CIDR`,
						},
					},
				},
				Description: `List of IP addresses allowed to access the service`,
			},
			"max_total_memory_gb": schema.NumberAttribute{
				Computed: true,
				PlanModifiers: []planmodifier.Number{
					numberplanmodifier.RequiresReplace(),
				},
				Optional:    true,
				Description: `Maximum total memory of all workers during auto-scaling in Gb. Available only for 'production' services. Must be a multiple of 12 and lower than 360 for non paid services or 720 for paid services.`,
			},
			"min_total_memory_gb": schema.NumberAttribute{
				Computed: true,
				PlanModifiers: []planmodifier.Number{
					numberplanmodifier.RequiresReplace(),
				},
				Optional:    true,
				Description: `Minimum total memory of all workers during auto-scaling in Gb. Available only for 'production' services. Must be a multiple of 12 and greater than 24.`,
			},
			"name": schema.StringAttribute{
				Computed:    true,
				Optional:    true,
				Description: `Name of the service.`,
			},
			"organization_id": schema.StringAttribute{
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
				Required:    true,
				Description: `ID of the organization that will own the service.`,
			},
			"password": schema.StringAttribute{
				Computed:    true,
				Description: `Password for the newly created service.`,
			},
			"region": schema.StringAttribute{
				Computed: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
				Optional: true,
				Validators: []validator.String{
					stringvalidator.OneOf(
						"ap-south-1",
						"ap-southeast-1",
						"eu-central-1",
						"eu-west-1",
						"us-east-1",
						"us-east-2",
						"us-west-2",
						"us-central1",
						"europe-west4",
						"asia-southeast1",
					),
				},
				MarkdownDescription: `must be one of [ap-south-1, ap-southeast-1, eu-central-1, eu-west-1, us-east-1, us-east-2, us-west-2, us-central1, europe-west4, asia-southeast1]` + "\n" +
					`Service region.`,
			},
			"state": schema.StringAttribute{
				Computed: true,
				Validators: []validator.String{
					stringvalidator.OneOf(
						"starting",
						"stopping",
						"terminating",
						"provisioning",
						"running",
						"stopped",
						"terminated",
						"degraded",
						"failed",
						"idle",
					),
				},
				MarkdownDescription: `must be one of [starting, stopping, terminating, provisioning, running, stopped, terminated, degraded, failed, idle]` + "\n" +
					`Current state of the service.`,
			},
			"tier": schema.StringAttribute{
				Computed: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
				Optional: true,
				Validators: []validator.String{
					stringvalidator.OneOf(
						"development",
						"production",
						"dedicated_high_mem",
						"dedicated_high_cpu",
						"dedicated_standard",
					),
				},
				MarkdownDescription: `must be one of [development, production, dedicated_high_mem, dedicated_high_cpu, dedicated_standard]` + "\n" +
					`Tier of the service: 'development', 'production', 'dedicated_high_mem', 'dedicated_high_cpu', 'dedicated_standard'. Production services scale, Development are fixed size.`,
			},
		},
	}
}

func (r *ServiceResource) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) {
	// Prevent panic if the provider has not been configured.
	if req.ProviderData == nil {
		return
	}

	client, ok := req.ProviderData.(*sdk.SDK)

	if !ok {
		resp.Diagnostics.AddError(
			"Unexpected Resource Configure Type",
			fmt.Sprintf("Expected *sdk.SDK, got: %T. Please report this issue to the provider developers.", req.ProviderData),
		)

		return
	}

	r.client = client
}

func (r *ServiceResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) {
	var data *ServiceResourceModel
	var item types.Object

	resp.Diagnostics.Append(req.Plan.Get(ctx, &item)...)
	if resp.Diagnostics.HasError() {
		return
	}

	resp.Diagnostics.Append(item.As(ctx, &data, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})...)

	if resp.Diagnostics.HasError() {
		return
	}

	servicePostRequest := data.ToCreateSDKType()
	organizationID := data.OrganizationID.ValueString()
	request := operations.PostV1OrganizationsOrganizationIDServicesRequest{
		ServicePostRequest: servicePostRequest,
		OrganizationID:     organizationID,
	}
	res, err := r.client.PostV1OrganizationsOrganizationIDServices(ctx, request)
	if err != nil {
		resp.Diagnostics.AddError("failure to invoke API", err.Error())
		return
	}
	if res == nil {
		resp.Diagnostics.AddError("unexpected response from API", fmt.Sprintf("%v", res))
		return
	}
	if res.StatusCode != 200 {
		resp.Diagnostics.AddError(fmt.Sprintf("unexpected response from API. Got an unexpected response code %v", res.StatusCode), debugResponse(res.RawResponse))
		return
	}
	if res.PostV1OrganizationsOrganizationIDServices200ApplicationJSONObject.Result == nil {
		resp.Diagnostics.AddError("unexpected response from API. No response body", debugResponse(res.RawResponse))
		return
	}
	if res.PostV1OrganizationsOrganizationIDServices200ApplicationJSONObject.Result.Password != nil {
		data.Password = types.StringValue(*res.PostV1OrganizationsOrganizationIDServices200ApplicationJSONObject.Result.Password)
	} else {
		data.Password = types.StringNull()
	}
	data.RefreshFromCreateResponse(res.PostV1OrganizationsOrganizationIDServices200ApplicationJSONObject.Result.Service)

	// Save updated data into Terraform state
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *ServiceResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) {
	var data *ServiceResourceModel
	var item types.Object

	resp.Diagnostics.Append(req.State.Get(ctx, &item)...)
	if resp.Diagnostics.HasError() {
		return
	}

	resp.Diagnostics.Append(item.As(ctx, &data, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})...)

	if resp.Diagnostics.HasError() {
		return
	}

	organizationID := data.OrganizationID.ValueString()
	serviceID := data.ID.ValueString()
	request := operations.GetV1OrganizationsOrganizationIDServicesServiceIDRequest{
		OrganizationID: organizationID,
		ServiceID:      serviceID,
	}
	res, err := r.client.GetV1OrganizationsOrganizationIDServicesServiceID(ctx, request)
	if err != nil {
		resp.Diagnostics.AddError("failure to invoke API", err.Error())
		return
	}
	if res == nil {
		resp.Diagnostics.AddError("unexpected response from API", fmt.Sprintf("%v", res))
		return
	}
	if res.StatusCode != 200 {
		resp.Diagnostics.AddError(fmt.Sprintf("unexpected response from API. Got an unexpected response code %v", res.StatusCode), debugResponse(res.RawResponse))
		return
	}
	if res.GetV1OrganizationsOrganizationIDServicesServiceID200ApplicationJSONObject.Result == nil {
		resp.Diagnostics.AddError("unexpected response from API. No response body", debugResponse(res.RawResponse))
		return
	}
	data.RefreshFromGetResponse(res.GetV1OrganizationsOrganizationIDServicesServiceID200ApplicationJSONObject.Result)

	// Save updated data into Terraform state
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *ServiceResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) {
	var data *ServiceResourceModel
	merge(ctx, req, resp, &data)
	if resp.Diagnostics.HasError() {
		return
	}

	servicePatchRequest := data.ToUpdateSDKType()
	organizationID := data.OrganizationID.ValueString()
	serviceID := data.ID.ValueString()
	request := operations.PatchV1OrganizationsOrganizationIDServicesServiceIDRequest{
		ServicePatchRequest: servicePatchRequest,
		OrganizationID:      organizationID,
		ServiceID:           serviceID,
	}
	res, err := r.client.PatchV1OrganizationsOrganizationIDServicesServiceID(ctx, request)
	if err != nil {
		resp.Diagnostics.AddError("failure to invoke API", err.Error())
		return
	}
	if res == nil {
		resp.Diagnostics.AddError("unexpected response from API", fmt.Sprintf("%v", res))
		return
	}
	if res.StatusCode != 200 {
		resp.Diagnostics.AddError(fmt.Sprintf("unexpected response from API. Got an unexpected response code %v", res.StatusCode), debugResponse(res.RawResponse))
		return
	}
	if res.PatchV1OrganizationsOrganizationIDServicesServiceID200ApplicationJSONObject.Result == nil {
		resp.Diagnostics.AddError("unexpected response from API. No response body", debugResponse(res.RawResponse))
		return
	}
	data.RefreshFromUpdateResponse(res.PatchV1OrganizationsOrganizationIDServicesServiceID200ApplicationJSONObject.Result)

	// Save updated data into Terraform state
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *ServiceResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) {
	var data *ServiceResourceModel
	var item types.Object

	resp.Diagnostics.Append(req.State.Get(ctx, &item)...)
	if resp.Diagnostics.HasError() {
		return
	}

	resp.Diagnostics.Append(item.As(ctx, &data, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})...)

	if resp.Diagnostics.HasError() {
		return
	}

	organizationID := data.OrganizationID.ValueString()
	serviceID := data.ID.ValueString()
	request := operations.DeleteV1OrganizationsOrganizationIDServicesServiceIDRequest{
		OrganizationID: organizationID,
		ServiceID:      serviceID,
	}
	res, err := r.client.DeleteV1OrganizationsOrganizationIDServicesServiceID(ctx, request)
	if err != nil {
		resp.Diagnostics.AddError("failure to invoke API", err.Error())
		return
	}
	if res == nil {
		resp.Diagnostics.AddError("unexpected response from API", fmt.Sprintf("%v", res))
		return
	}
	if fmt.Sprintf("%v", res.StatusCode)[0] != '2' {
		resp.Diagnostics.AddError(fmt.Sprintf("unexpected response from API. Got an unexpected response code %v", res.StatusCode), debugResponse(res.RawResponse))
		return
	}

}

func (r *ServiceResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) {
	resp.Diagnostics.AddError("Not Implemented", "No available import state operation is available for resource service.")
}
